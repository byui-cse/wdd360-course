---
title: Svelte Part 1
description: This activity will give some practice with using Svelte to create components by creating a reusable dialog and user management menu
time: 1 hours
---
import Details from '../../components/Details.astro'
import Figure from '../../components/Figure.astro'

## Introduction

A very popular way to build web apps currently is by creating re-usable components. These components have all of the markup, styling, and functionality packaged up in an easy to use form. The `productDetails` module we made earlier followed this form to some extent. all we had to do to get a product to display with it's details was to call a function.

Our module works, but has a few drawbacks with performance and implementation. Because it can be fairly difficult to solve those problems, and because almost everyone writing web applications runs into them many libraries and frameworks have been built to help.

Part of your reading for this week was a [tutorial on Svelte](https://learn.svelte.dev/tutorial/welcome-to-svelte). Svelte is a framework for creating modern web applications with components. We will be using it in our project starting with this week to help us build our re-usable components.

One nice thing about Svelte components is that they are file based. One file for all the HTML markup, CSS, and Javascript. Another nice thing is that the templates are mostly just HTML...with some Svelte specific templating additions.

## **01** Getting Started

We should start by getting a local project setup that we can use to practice creating Svelte components. This is pretty easy to do with a good build tool like Vite.  Open up VS Code to your sandbox project for the course. Then run the following commands:

```bash
npm create vite@latest svelte-ponder
```

When prompted select `svelte` as the framework, then typescript. Then `cd` into the new folder that was created. Next run:

```bash
npm install
```
This will install all the dependencies we need to get started. Finally run:

```bash
npm run dev
```

This will start a local development server and open up a browser window to show you the default Svelte app.

>if you prefer using `pnpm` you can use that instead of `npm`. 

Take a look at `App.svelte` in the `src` folder. This is the main component for the app. You can edit this file to change what is shown on the page. Try changing some of the text and see what happens in the browser.


## **02** Create a Login component

Before we create our user menu and dialog components, let's start with a simple login form component. This will be a simple form with email and password fields and a login button.
1. Create a new file called `src/lib/Login.svelte`. This will be our login component.
2. Add a form with labels and inputs for email and password. Then add a button with the text `Log In`. Add an `onsubmit` attribute to the form that calls a function called `loginHandler` that we will create later.
3. Add a `script` element and create the `loginHandler` function. We will not implement this fully today, but will just make the button log a message to the console when clicked.
4. Add some basic styling to the component. You can add a `style` element to the component and add some CSS to style the form.
5. Test the component by importing it into `App.svelte` and adding it to the template. You should see the form on the page and when you click the button it should log a message to the console.



## **03** Create the Dialog Component

Often we want to show content that is not always visible on our page. This could be a menu, a tooltip (popover), or a dialog asking for settings or other information. A modal is a type of dialog that blocks access to other content on the page until it is dismissed. This is something that could be useful in a lot of places. For example, if we have a user menu that shows up when the user clicks on their profile icon, we generally want that to be easy to dismiss so they can continue with what they were doing. 

On the other hand, if something like a login form shows up, we generally want the user to deal with it...either fill it out or dismiss it, before they continue with what they were doing. Modal dialogs are useful things that could show up in our application. We are going to create a `Dialog.svelte` component that can be used as needed and create a modal dialog with customizable contents. 

A dialog needs to have some trigger...usually a button and a container that will hold the content of the dialog that is hidden by default. Part of that container must hold a way (usually another button) to close the dialog.  HTML actually has a `dialog` element that automatically is hidden by default. We will use that.

  To open a `dialog` we get a reference to the element in Javascript then call its `.show()` or `.showModal()` method. To close it we call `.close()`.

1. Create a file called `src/js/components/Dialog.svelte`.
2. Add a `button` with text "Open", a `dialog`, and inside the dialog another `button` with an "X". For now let's add our Login component inside the dialog as well.
3. Add some CSS to style it. At a minimum the "X" button should be moved to the top right corner.
4. We are going to need a reference to our dialog in order to open and close it. We could just use a `document.querySelector` but with Svelte we have another option. We can bind a reference to any element easily. Create a variable called `dialogRef`. Bind it to our `dialog` element. `<dialog bind:this={dialogRef}>`
5.  Create two functions in our component: `open` and `close`. They should both take no arguments.
6. In our `open()` function, call `dialogRef.showModal()`. In our `close()` function, call `dialogRef.close()`.
>We should also add an Accessibility thing that has been missing as well. It is good to let assitive technologies know what state our menu is in. We can do this with `aria-expanded`. We can set it to true or false depending on whether our menu is open or closed. In the `open` function set it to true and in our `close()` function set it to false.
7. Finally set an `onclick` attribute on our `button` that calls our `open()` function.
8. Add an `onclick` event listener to the button in our `dialog`. It should call our `close()` function.
9. Test our component. Import the component into the `App` component. Then you can add it in by treating it just like any other HTML element `<Dialog ></Dialog>`.
10. Test our component by opening it and closing it. 

## **05** Passing content into components.

In order to really have a reusable component we need to be able to pass content into it. We can do that by either using props, or children. We will have need of both. We will pass in the label for the opening button as a prop, and the main contents of the open dialog as children (which is also a prop).

1. Open the `Dialog.svelte` file. We need to make some changes to allow for passing in children and a label prop.
2. Towards the top of the `script` (below an imports) add the following: `let {label, children} = $props();`. `label` is the attribute. `children` is any contents that we add inside of the element.
3. We can use the label prop in our template by just wrapping it in `{label}`. Replace the words in the button that is for opening the dialog ("Open") with `{label}`
4. Finally we need to insert the children. We will use the `{@render}` command to do this. Inside the `<dialog>` element add `{@render children()}`. That should replace everything but the  "X" button.
5. Test the component again by updating `App.svelte`. This time add some content inside the `<Dialog>` element. For example:
```svelte
<Dialog label="Log In">
    <Login />
</Dialog>
```
6. Test.

<Figure src="../../../../images/svelte-modal-dialog.webp" alt="Svelte Login Component" />

## **04** Modal vs Non-Modal Dialogs

Another enhancement we could make to our dialog component is to allow it to be either modal or non-modal. We can do this by adding a prop called `modal` that is a boolean. If it is true we will call `showModal()`. If it is false we will call `show()`.

1. Open `Dialog.svelte` again.
2. In the `script` element add `let {modal = true} = $props();`. This will create a prop called `modal` that defaults to true.
3. Update the `open()` function to check the value of `modal`. If it is true call `dialogRef.showModal()`. If it is false call `dialogRef.show()`.
4. Test the component again by updating `App.svelte`. This time add the `modal` attribute and set it to false. For example:
```svelte
<Dialog label="Non-Modal Dialog" modal={false}>
    <p>This is a non-modal dialog.</p>
</Dialog>
```

<Figure src="../../../../images/svelte-non-modal-dialog.webp" alt="Svelte non modal dialog" />

## **05** Close the Dialog

You might read the title above and think...wait...we already have a way to close the dialog. Right now the only way to close the dialog is to click on the "X" button in the top right corner. Let's say that we are using the dialog for our login form. If the user successfully logs in the dialog should close automatically. Currently there is no way for the Login component to tell the Dialog component to close itself. We need to modify our dialog to provide a way for children to tell it to close.
1. Open `Dialog.svelte` again.
2. Find the line where we render the children (`{@render children()}`). Provide our close function as an argument to the `children()` function. It should look like this: `{@render children(closeDialog)}`. This will make that function available to any children that are passed in.
3. Now we need to update our `App.svelte` file to accept that argument. Open `App.svelte`.
4. In the `Dialog` element, update the `Login` component to accept the argument. In order to do this we have to use a Svelte [snippet](https://svelte.dev/docs/svelte/snippet#Passing-snippets-to-components-Implicit-children-snippet). It should look like this:
```svelte
<Dialog label="Login">
        {#snippet children(closeDialog: () => void)} // the ": () => void" is for typescript
          <Login onSuccess={closeDialog} />
        {/snippet}
</Dialog>
```
4. Now we need to update our `Login.svelte` component to accept that argument. Open `Login.svelte`.
5. In the `script` element add `let {onSuccess} = $props();`
6. In the `loginHandler` function, after logging in successfully (for now just after logging to the console) call `onSuccess()`. This will call the `closeDialog` function in the Dialog component.


## **05** Closing on outside click (stretch)

One common feature of dialogs is to close them when the user clicks outside of the dialog or when they hit the `esc` key. Hitting `esc` to close works automatically with modal dialogs. We can implement this for non-modal dialogs by adding a couple more event listeners to our dialog.

1. Open `Dialog.svelte` again.
2. Add a function called `handleClickOutside`. Import `onMount` from svelte and call it. It expects a callback function as an argument. Create an anonymous function. Inside of that function check to see if the current Dialog is a model or not. If it is not then add an event listener to the `document` that watches for a click. Use the `handleClickOutside` function. 
```svelte
onMount(() => {
    if (!modal) {
      document.addEventListener('click', handleClickOutside);
    }
  });
```
3. Implement `handleClickOutside`. In that function we need to check to see where the user clicked. If they clicked outside of the dialog we should close it. (hint. the `event.target` property will tell you where the user clicked. Also check out the [contains](https://developer.mozilla.org/en-US/docs/Web/API/Node/contains) method of elements.)
4. To enable the `esc` key to close the dialog we can add another event listener to the `document` in the `onMount` function. This one should listen for `keydown` events. Create a function called `handleKeyDown` that will be called when a key is pressed.
5. In the `handleKeyDown` function check to see if `event.key` is equal to `Escape`. If it is, call the `closeDialog()` function.
6. Test the component again by opening the dialog and pressing the `esc` key. It should close. Try also clicking outside the dialog when it is non-modal. It should close as well.

>When using the `onMount` function to add event listeners to the `document` it is a good idea to also remove those event listeners when the component is destroyed...to clean up after yourself. You can do this by returning a function from the `onMount` callback that removes the event listeners you added.
> Here is an example:
>```svelte
>onMount(() => {
>    if (!modal) {
>      document.addEventListener('click', clickHandler);
>
>      return () => {
>        document.removeEventListener('click', clickHandler);
>      };
>    }
>  });
>```


You can find the templates below if you get lost.

<Details summary="Dialog Template">
```svelte
<button onclick={openDialog}>{label}</button>
<dialog bind:this={dialogRef} aria-hidden="true">
  <div class="dialog-header">
    <button onclick={closeDialog} aria-label="Close dialog">X</button>
  </div>
  <div>
    {@render children(closeDialog)}
  </div>
</dialog>
```
</Details>

<Details summary="Login Template">
```svelte
<h2>Login</h2>
<form onsubmit={loginHandler}>
  <label for="email">Email</label>
  <input type="text" id="email" bind:value={email} />
  <label for="password">Password</label>
  <input type="password" id="password" bind:value={password} />
  
  <button>Login</button>
</form>
<button class="link-style-button">Register</button>

```
</Details>


## **06** Submit

When you have completed the task, make sure to commit and push, then submit a link to your repository on the assignment submission page.